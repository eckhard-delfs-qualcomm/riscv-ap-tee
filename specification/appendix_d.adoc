[[appendix_d]]
== Appendix D: M-mode TSM based deployment model

This deployment model targets high-assurance systems whose design might be constrained 
by real-time and formal verification requirements. It trade offs a feature-rich design supporting 
dynamic resource allocation, for simpler implementation, where the correctness can be formally verified.

[id=depd]
[caption="Figure {counter:image}"]
[title= ": M-mode TSM based deployment model for CoVE"]
image::img_11.png[align=center]

=== Overview
<<depd>> shows that the deployment model supports a single confidential supervisor domain in which 
the TSM runs along with the TSM driver in the M-mode. This single confidential supervisor domain can run multiple 
TVMs that are isolated from each other using the MMU, i.e., G-stage page tables managed by TSM. TSM isolates the 
hosting supervisor domain (i.e., OS/VMM and non-confidential applications and VMs) from the confidential supervisor 
domain (TSM and TVMs) using a hardware memory isolation mechanism, like PMP. The Smmtt extension is therefore not required. 
IO accesses to confidential memory must be prevented, for example, with IOPMP.

[NOTE]
====
Since the TSM is not required to run in the HS-mode, this deployment model supports systems that emulate the 
hypervisor extension.
====

=== Static memory partitioning
The deployment model proposes static partitioning of memory into confidential and non-confidential to simplify 
formal reasoning about the correctness of the TVM execution and isolation. TSM performs this paritioning early 
during the boot of the platform, resulting in the following advantages: (1) simplified formal reasoning about the 
ownership of memory, (2) attestation that covers static system configuration (e.g., values of PMP registers), 
(3) reduced attack surface between OS/VMM and TSM (narrower ABI). A possible negative consequence of 
static partitioning is underutilization of resources.

=== TVM creation
To reduce the complexity of the TSM implementation, the TSM creates a TVM as a result of a single operation triggered with 
the `sbi_covg_promote_to_tvm()` call. Specifically, OS/VMM initializes and starts a regular VM, which early during the 
boot process requests to be promoted to TVM. This call is reflected to the TSM which copies TVM data, the page table 
configuration, and the vCPU state into confidential memory. 

=== Local attestation
Embedded systems might operate without access to a network, which prevents use of remote attestation. For this 
reason, this deployment model also supports local attestation, in which the TSM attests to the integrity of the TVM image 
during its creation and allows its creation only when it contains a specfic cryptographic authentication blob. This 
attestation blob will carry a cryptographic proof issued with the expected attestation key specific to the TSM integrity 
and platform configuration. The call to promote to a TVM requires two parameters a pointer to the FDT and a pointer 
to some cryptographic data. If the pointer to cryptographic data is zero, then remote attestation is used, 
otherwise local attestation is used. Local attestation is strongest when it is hardware enforced.  

Attestation in this environments two requires two properties. 
. The TVM must be able to verify that the the configuration
of the hardware platform is acceptable.
. The embedded platform must be able to verify that the TVM is authorized to 
run on the platform. Separate mechanisms are used to acheive these goals.


====VM (TV) Authorization
The TSM must have a list of public keys of those authorized to sign VM for execution on the platform. The 
cryptographic data associated with the TVM will be
signed with a private key. When the VM request to be promoted to a TVM the signature on the  the cryptographic data
will be checked. If the signature is not valid the TSM will not convert the VM and terminate execution of the
VM. The method for provisioning thes keys into the TSM is outside the scope of this specification.

====Hardware Platform configuration
For local attestation the standard approah is to encrypt the disk of the VM (that will become a TVM). THe key 
that is used to decrypt the disk is sealed (in a TPM sense) to the measurment of the platform. THe creator decides what
values are required inorde for the key to be released. Sealing prevents the valuse from being exposed during transmission
of the VM. The principal is that the key will not be beavailabel unless the hardware is in the correct state. 



=== Further recommendations
Embedded systems with real-time requirements must have a fixed upper bounded execution time. This requires determining 
the maximal number of instructions that can execute between TVM context switches. From this reason, this deployment model 
recommends an uninterruptible TSM. <<depd2>> shows this operation mode, in which TSM running in M-mode exposes COVH and 
COVG ABI to OS/VMM and TVM, respectively. VM ECALLS trap directly to TSM due to the `medeleg` configuration and all 
interrupts during TVM execution trap in TSM due to the `mideleg` configuration. 

[id=depd2]
[caption="Figure {counter:image}"]
[title= ": TSM operation"]
image::img_13.png[align=center]